// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message_tracethreat.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "message_tracethreat.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace scan_threat {

namespace {

const ::google::protobuf::Descriptor* InfectedFileInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InfectedFileInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfo_EncodeType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfo_FileType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfo_StatusResult_descriptor_ = NULL;
const ::google::protobuf::Descriptor* InfectedFileInfoRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InfectedFileInfoRequest_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfoRequest_EncodeType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfoRequest_FileType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfoRequest_StatusResult_descriptor_ = NULL;
const ::google::protobuf::Descriptor* InfectedFileInfoResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InfectedFileInfoResponse_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfoResponse_EncodeType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfoResponse_FileType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InfectedFileInfoResponse_StatusResult_descriptor_ = NULL;
const ::google::protobuf::ServiceDescriptor* InfectedFileInfoService_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_message_5ftracethreat_2eproto() {
  protobuf_AddDesc_message_5ftracethreat_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "message_tracethreat.proto");
  GOOGLE_CHECK(file != NULL);
  InfectedFileInfo_descriptor_ = file->message_type(0);
  static const int InfectedFileInfo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, machine_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, encode_sig_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, file_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, file_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, status_result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, virus_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, binary_),
  };
  InfectedFileInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InfectedFileInfo_descriptor_,
      InfectedFileInfo::default_instance_,
      InfectedFileInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InfectedFileInfo));
  InfectedFileInfo_EncodeType_descriptor_ = InfectedFileInfo_descriptor_->enum_type(0);
  InfectedFileInfo_FileType_descriptor_ = InfectedFileInfo_descriptor_->enum_type(1);
  InfectedFileInfo_StatusResult_descriptor_ = InfectedFileInfo_descriptor_->enum_type(2);
  InfectedFileInfoRequest_descriptor_ = file->message_type(1);
  static const int InfectedFileInfoRequest_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, machine_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, encode_sig_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, file_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, file_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, status_result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, virus_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, binary_),
  };
  InfectedFileInfoRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InfectedFileInfoRequest_descriptor_,
      InfectedFileInfoRequest::default_instance_,
      InfectedFileInfoRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InfectedFileInfoRequest));
  InfectedFileInfoRequest_EncodeType_descriptor_ = InfectedFileInfoRequest_descriptor_->enum_type(0);
  InfectedFileInfoRequest_FileType_descriptor_ = InfectedFileInfoRequest_descriptor_->enum_type(1);
  InfectedFileInfoRequest_StatusResult_descriptor_ = InfectedFileInfoRequest_descriptor_->enum_type(2);
  InfectedFileInfoResponse_descriptor_ = file->message_type(2);
  static const int InfectedFileInfoResponse_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, machine_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, encode_sig_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, file_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, file_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, status_result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, virus_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, binary_),
  };
  InfectedFileInfoResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InfectedFileInfoResponse_descriptor_,
      InfectedFileInfoResponse::default_instance_,
      InfectedFileInfoResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InfectedFileInfoResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InfectedFileInfoResponse));
  InfectedFileInfoResponse_EncodeType_descriptor_ = InfectedFileInfoResponse_descriptor_->enum_type(0);
  InfectedFileInfoResponse_FileType_descriptor_ = InfectedFileInfoResponse_descriptor_->enum_type(1);
  InfectedFileInfoResponse_StatusResult_descriptor_ = InfectedFileInfoResponse_descriptor_->enum_type(2);
  InfectedFileInfoService_descriptor_ = file->service(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_message_5ftracethreat_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InfectedFileInfo_descriptor_, &InfectedFileInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InfectedFileInfoRequest_descriptor_, &InfectedFileInfoRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InfectedFileInfoResponse_descriptor_, &InfectedFileInfoResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_message_5ftracethreat_2eproto() {
  delete InfectedFileInfo::default_instance_;
  delete InfectedFileInfo_reflection_;
  delete InfectedFileInfoRequest::default_instance_;
  delete InfectedFileInfoRequest_reflection_;
  delete InfectedFileInfoResponse::default_instance_;
  delete InfectedFileInfoResponse_reflection_;
}

void protobuf_AddDesc_message_5ftracethreat_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\031message_tracethreat.proto\022\013scan_threat"
    "\"\301\003\n\020InfectedFileInfo\022\014\n\004uuid\030\001 \001(\014\022\024\n\014m"
    "achine_name\030\002 \001(\014\022\n\n\002ip\030\003 \001(\014\022A\n\017encode_"
    "sig_type\030\004 \001(\0162(.scan_threat.InfectedFil"
    "eInfo.EncodeType\022\021\n\tfile_name\030\005 \001(\014\022\021\n\tf"
    "ile_type\030\006 \001(\014\022A\n\rstatus_result\030\007 \001(\0162*."
    "scan_threat.InfectedFileInfo.StatusResul"
    "t\022\022\n\nvirus_name\030\010 \001(\014\022\016\n\006binary\030\t \001(\014\"W\n"
    "\nEncodeType\022\007\n\003MD5\020\001\022\016\n\nMD5_HEADER\020\002\022\014\n\010"
    "MD5_BODY\020\003\022\t\n\005SHA_1\020\004\022\013\n\007SHA_256\020\005\022\n\n\006SS"
    "DEEP\020\006\"(\n\010FileType\022\006\n\002PE\020\001\022\007\n\003ELF\020\002\022\013\n\007P"
    "ROCESS\020\003\"*\n\014StatusResult\022\014\n\010POSITIVE\020\001\022\014"
    "\n\010NEGATIVE\020\002\"\326\003\n\027InfectedFileInfoRequest"
    "\022\014\n\004uuid\030\001 \001(\014\022\024\n\014machine_name\030\002 \001(\014\022\n\n\002"
    "ip\030\003 \001(\014\022H\n\017encode_sig_type\030\004 \001(\0162/.scan"
    "_threat.InfectedFileInfoRequest.EncodeTy"
    "pe\022\021\n\tfile_name\030\005 \001(\014\022\021\n\tfile_type\030\006 \001(\014"
    "\022H\n\rstatus_result\030\007 \001(\01621.scan_threat.In"
    "fectedFileInfoRequest.StatusResult\022\022\n\nvi"
    "rus_name\030\010 \001(\014\022\016\n\006binary\030\t \001(\014\"W\n\nEncode"
    "Type\022\007\n\003MD5\020\001\022\016\n\nMD5_HEADER\020\002\022\014\n\010MD5_BOD"
    "Y\020\003\022\t\n\005SHA_1\020\004\022\013\n\007SHA_256\020\005\022\n\n\006SSDEEP\020\006\""
    "(\n\010FileType\022\006\n\002PE\020\001\022\007\n\003ELF\020\002\022\013\n\007PROCESS\020"
    "\003\"*\n\014StatusResult\022\014\n\010POSITIVE\020\001\022\014\n\010NEGAT"
    "IVE\020\002\"\331\003\n\030InfectedFileInfoResponse\022\014\n\004uu"
    "id\030\001 \001(\014\022\024\n\014machine_name\030\002 \001(\014\022\n\n\002ip\030\003 \001"
    "(\014\022I\n\017encode_sig_type\030\004 \001(\01620.scan_threa"
    "t.InfectedFileInfoResponse.EncodeType\022\021\n"
    "\tfile_name\030\005 \001(\014\022\021\n\tfile_type\030\006 \001(\014\022I\n\rs"
    "tatus_result\030\007 \001(\01622.scan_threat.Infecte"
    "dFileInfoResponse.StatusResult\022\022\n\nvirus_"
    "name\030\010 \001(\014\022\016\n\006binary\030\t \001(\014\"W\n\nEncodeType"
    "\022\007\n\003MD5\020\001\022\016\n\nMD5_HEADER\020\002\022\014\n\010MD5_BODY\020\003\022"
    "\t\n\005SHA_1\020\004\022\013\n\007SHA_256\020\005\022\n\n\006SSDEEP\020\006\"(\n\010F"
    "ileType\022\006\n\002PE\020\001\022\007\n\003ELF\020\002\022\013\n\007PROCESS\020\003\"*\n"
    "\014StatusResult\022\014\n\010POSITIVE\020\001\022\014\n\010NEGATIVE\020"
    "\0022z\n\027InfectedFileInfoService\022_\n\020Infected"
    "FileInfo\022$.scan_threat.InfectedFileInfoR"
    "equest\032%.scan_threat.InfectedFileInfoRes"
    "ponseB\003\200\001\001", 1570);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "message_tracethreat.proto", &protobuf_RegisterTypes);
  InfectedFileInfo::default_instance_ = new InfectedFileInfo();
  InfectedFileInfoRequest::default_instance_ = new InfectedFileInfoRequest();
  InfectedFileInfoResponse::default_instance_ = new InfectedFileInfoResponse();
  InfectedFileInfo::default_instance_->InitAsDefaultInstance();
  InfectedFileInfoRequest::default_instance_->InitAsDefaultInstance();
  InfectedFileInfoResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_message_5ftracethreat_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_message_5ftracethreat_2eproto {
  StaticDescriptorInitializer_message_5ftracethreat_2eproto() {
    protobuf_AddDesc_message_5ftracethreat_2eproto();
  }
} static_descriptor_initializer_message_5ftracethreat_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* InfectedFileInfo_EncodeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfo_EncodeType_descriptor_;
}
bool InfectedFileInfo_EncodeType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfo_EncodeType InfectedFileInfo::MD5;
const InfectedFileInfo_EncodeType InfectedFileInfo::MD5_HEADER;
const InfectedFileInfo_EncodeType InfectedFileInfo::MD5_BODY;
const InfectedFileInfo_EncodeType InfectedFileInfo::SHA_1;
const InfectedFileInfo_EncodeType InfectedFileInfo::SHA_256;
const InfectedFileInfo_EncodeType InfectedFileInfo::SSDEEP;
const InfectedFileInfo_EncodeType InfectedFileInfo::EncodeType_MIN;
const InfectedFileInfo_EncodeType InfectedFileInfo::EncodeType_MAX;
const int InfectedFileInfo::EncodeType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* InfectedFileInfo_FileType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfo_FileType_descriptor_;
}
bool InfectedFileInfo_FileType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfo_FileType InfectedFileInfo::PE;
const InfectedFileInfo_FileType InfectedFileInfo::ELF;
const InfectedFileInfo_FileType InfectedFileInfo::PROCESS;
const InfectedFileInfo_FileType InfectedFileInfo::FileType_MIN;
const InfectedFileInfo_FileType InfectedFileInfo::FileType_MAX;
const int InfectedFileInfo::FileType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* InfectedFileInfo_StatusResult_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfo_StatusResult_descriptor_;
}
bool InfectedFileInfo_StatusResult_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfo_StatusResult InfectedFileInfo::POSITIVE;
const InfectedFileInfo_StatusResult InfectedFileInfo::NEGATIVE;
const InfectedFileInfo_StatusResult InfectedFileInfo::StatusResult_MIN;
const InfectedFileInfo_StatusResult InfectedFileInfo::StatusResult_MAX;
const int InfectedFileInfo::StatusResult_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int InfectedFileInfo::kUuidFieldNumber;
const int InfectedFileInfo::kMachineNameFieldNumber;
const int InfectedFileInfo::kIpFieldNumber;
const int InfectedFileInfo::kEncodeSigTypeFieldNumber;
const int InfectedFileInfo::kFileNameFieldNumber;
const int InfectedFileInfo::kFileTypeFieldNumber;
const int InfectedFileInfo::kStatusResultFieldNumber;
const int InfectedFileInfo::kVirusNameFieldNumber;
const int InfectedFileInfo::kBinaryFieldNumber;
#endif  // !_MSC_VER

InfectedFileInfo::InfectedFileInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InfectedFileInfo::InitAsDefaultInstance() {
}

InfectedFileInfo::InfectedFileInfo(const InfectedFileInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InfectedFileInfo::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encode_sig_type_ = 1;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_result_ = 1;
  virus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  binary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InfectedFileInfo::~InfectedFileInfo() {
  SharedDtor();
}

void InfectedFileInfo::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_name_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_type_ != &::google::protobuf::internal::kEmptyString) {
    delete file_type_;
  }
  if (virus_name_ != &::google::protobuf::internal::kEmptyString) {
    delete virus_name_;
  }
  if (binary_ != &::google::protobuf::internal::kEmptyString) {
    delete binary_;
  }
  if (this != default_instance_) {
  }
}

void InfectedFileInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InfectedFileInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfo_descriptor_;
}

const InfectedFileInfo& InfectedFileInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_5ftracethreat_2eproto();
  return *default_instance_;
}

InfectedFileInfo* InfectedFileInfo::default_instance_ = NULL;

InfectedFileInfo* InfectedFileInfo::New() const {
  return new InfectedFileInfo;
}

void InfectedFileInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    if (has_machine_name()) {
      if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
        machine_name_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    encode_sig_type_ = 1;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    if (has_file_type()) {
      if (file_type_ != &::google::protobuf::internal::kEmptyString) {
        file_type_->clear();
      }
    }
    status_result_ = 1;
    if (has_virus_name()) {
      if (virus_name_ != &::google::protobuf::internal::kEmptyString) {
        virus_name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_binary()) {
      if (binary_ != &::google::protobuf::internal::kEmptyString) {
        binary_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InfectedFileInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_machine_name;
        break;
      }

      // optional bytes machine_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_machine_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_machine_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ip;
        break;
      }

      // optional bytes ip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_encode_sig_type;
        break;
      }

      // optional .scan_threat.InfectedFileInfo.EncodeType encode_sig_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encode_sig_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::scan_threat::InfectedFileInfo_EncodeType_IsValid(value)) {
            set_encode_sig_type(static_cast< ::scan_threat::InfectedFileInfo_EncodeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_file_name;
        break;
      }

      // optional bytes file_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_file_type;
        break;
      }

      // optional bytes file_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_file_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_status_result;
        break;
      }

      // optional .scan_threat.InfectedFileInfo.StatusResult status_result = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::scan_threat::InfectedFileInfo_StatusResult_IsValid(value)) {
            set_status_result(static_cast< ::scan_threat::InfectedFileInfo_StatusResult >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_virus_name;
        break;
      }

      // optional bytes virus_name = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_virus_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_virus_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_binary;
        break;
      }

      // optional bytes binary = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_binary:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_binary()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InfectedFileInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->uuid(), output);
  }

  // optional bytes machine_name = 2;
  if (has_machine_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->machine_name(), output);
  }

  // optional bytes ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->ip(), output);
  }

  // optional .scan_threat.InfectedFileInfo.EncodeType encode_sig_type = 4;
  if (has_encode_sig_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->encode_sig_type(), output);
  }

  // optional bytes file_name = 5;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->file_name(), output);
  }

  // optional bytes file_type = 6;
  if (has_file_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->file_type(), output);
  }

  // optional .scan_threat.InfectedFileInfo.StatusResult status_result = 7;
  if (has_status_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->status_result(), output);
  }

  // optional bytes virus_name = 8;
  if (has_virus_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->virus_name(), output);
  }

  // optional bytes binary = 9;
  if (has_binary()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->binary(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InfectedFileInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes uuid = 1;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->uuid(), target);
  }

  // optional bytes machine_name = 2;
  if (has_machine_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->machine_name(), target);
  }

  // optional bytes ip = 3;
  if (has_ip()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->ip(), target);
  }

  // optional .scan_threat.InfectedFileInfo.EncodeType encode_sig_type = 4;
  if (has_encode_sig_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->encode_sig_type(), target);
  }

  // optional bytes file_name = 5;
  if (has_file_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->file_name(), target);
  }

  // optional bytes file_type = 6;
  if (has_file_type()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->file_type(), target);
  }

  // optional .scan_threat.InfectedFileInfo.StatusResult status_result = 7;
  if (has_status_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->status_result(), target);
  }

  // optional bytes virus_name = 8;
  if (has_virus_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->virus_name(), target);
  }

  // optional bytes binary = 9;
  if (has_binary()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        9, this->binary(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InfectedFileInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // optional bytes machine_name = 2;
    if (has_machine_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->machine_name());
    }

    // optional bytes ip = 3;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ip());
    }

    // optional .scan_threat.InfectedFileInfo.EncodeType encode_sig_type = 4;
    if (has_encode_sig_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->encode_sig_type());
    }

    // optional bytes file_name = 5;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->file_name());
    }

    // optional bytes file_type = 6;
    if (has_file_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->file_type());
    }

    // optional .scan_threat.InfectedFileInfo.StatusResult status_result = 7;
    if (has_status_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status_result());
    }

    // optional bytes virus_name = 8;
    if (has_virus_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->virus_name());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes binary = 9;
    if (has_binary()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->binary());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InfectedFileInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InfectedFileInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InfectedFileInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InfectedFileInfo::MergeFrom(const InfectedFileInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_machine_name()) {
      set_machine_name(from.machine_name());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_encode_sig_type()) {
      set_encode_sig_type(from.encode_sig_type());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_type()) {
      set_file_type(from.file_type());
    }
    if (from.has_status_result()) {
      set_status_result(from.status_result());
    }
    if (from.has_virus_name()) {
      set_virus_name(from.virus_name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_binary()) {
      set_binary(from.binary());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InfectedFileInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InfectedFileInfo::CopyFrom(const InfectedFileInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfectedFileInfo::IsInitialized() const {

  return true;
}

void InfectedFileInfo::Swap(InfectedFileInfo* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(machine_name_, other->machine_name_);
    std::swap(ip_, other->ip_);
    std::swap(encode_sig_type_, other->encode_sig_type_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_type_, other->file_type_);
    std::swap(status_result_, other->status_result_);
    std::swap(virus_name_, other->virus_name_);
    std::swap(binary_, other->binary_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InfectedFileInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InfectedFileInfo_descriptor_;
  metadata.reflection = InfectedFileInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* InfectedFileInfoRequest_EncodeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoRequest_EncodeType_descriptor_;
}
bool InfectedFileInfoRequest_EncodeType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfoRequest_EncodeType InfectedFileInfoRequest::MD5;
const InfectedFileInfoRequest_EncodeType InfectedFileInfoRequest::MD5_HEADER;
const InfectedFileInfoRequest_EncodeType InfectedFileInfoRequest::MD5_BODY;
const InfectedFileInfoRequest_EncodeType InfectedFileInfoRequest::SHA_1;
const InfectedFileInfoRequest_EncodeType InfectedFileInfoRequest::SHA_256;
const InfectedFileInfoRequest_EncodeType InfectedFileInfoRequest::SSDEEP;
const InfectedFileInfoRequest_EncodeType InfectedFileInfoRequest::EncodeType_MIN;
const InfectedFileInfoRequest_EncodeType InfectedFileInfoRequest::EncodeType_MAX;
const int InfectedFileInfoRequest::EncodeType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* InfectedFileInfoRequest_FileType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoRequest_FileType_descriptor_;
}
bool InfectedFileInfoRequest_FileType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfoRequest_FileType InfectedFileInfoRequest::PE;
const InfectedFileInfoRequest_FileType InfectedFileInfoRequest::ELF;
const InfectedFileInfoRequest_FileType InfectedFileInfoRequest::PROCESS;
const InfectedFileInfoRequest_FileType InfectedFileInfoRequest::FileType_MIN;
const InfectedFileInfoRequest_FileType InfectedFileInfoRequest::FileType_MAX;
const int InfectedFileInfoRequest::FileType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* InfectedFileInfoRequest_StatusResult_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoRequest_StatusResult_descriptor_;
}
bool InfectedFileInfoRequest_StatusResult_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfoRequest_StatusResult InfectedFileInfoRequest::POSITIVE;
const InfectedFileInfoRequest_StatusResult InfectedFileInfoRequest::NEGATIVE;
const InfectedFileInfoRequest_StatusResult InfectedFileInfoRequest::StatusResult_MIN;
const InfectedFileInfoRequest_StatusResult InfectedFileInfoRequest::StatusResult_MAX;
const int InfectedFileInfoRequest::StatusResult_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int InfectedFileInfoRequest::kUuidFieldNumber;
const int InfectedFileInfoRequest::kMachineNameFieldNumber;
const int InfectedFileInfoRequest::kIpFieldNumber;
const int InfectedFileInfoRequest::kEncodeSigTypeFieldNumber;
const int InfectedFileInfoRequest::kFileNameFieldNumber;
const int InfectedFileInfoRequest::kFileTypeFieldNumber;
const int InfectedFileInfoRequest::kStatusResultFieldNumber;
const int InfectedFileInfoRequest::kVirusNameFieldNumber;
const int InfectedFileInfoRequest::kBinaryFieldNumber;
#endif  // !_MSC_VER

InfectedFileInfoRequest::InfectedFileInfoRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InfectedFileInfoRequest::InitAsDefaultInstance() {
}

InfectedFileInfoRequest::InfectedFileInfoRequest(const InfectedFileInfoRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InfectedFileInfoRequest::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encode_sig_type_ = 1;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_result_ = 1;
  virus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  binary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InfectedFileInfoRequest::~InfectedFileInfoRequest() {
  SharedDtor();
}

void InfectedFileInfoRequest::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_name_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_type_ != &::google::protobuf::internal::kEmptyString) {
    delete file_type_;
  }
  if (virus_name_ != &::google::protobuf::internal::kEmptyString) {
    delete virus_name_;
  }
  if (binary_ != &::google::protobuf::internal::kEmptyString) {
    delete binary_;
  }
  if (this != default_instance_) {
  }
}

void InfectedFileInfoRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InfectedFileInfoRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoRequest_descriptor_;
}

const InfectedFileInfoRequest& InfectedFileInfoRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_5ftracethreat_2eproto();
  return *default_instance_;
}

InfectedFileInfoRequest* InfectedFileInfoRequest::default_instance_ = NULL;

InfectedFileInfoRequest* InfectedFileInfoRequest::New() const {
  return new InfectedFileInfoRequest;
}

void InfectedFileInfoRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    if (has_machine_name()) {
      if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
        machine_name_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    encode_sig_type_ = 1;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    if (has_file_type()) {
      if (file_type_ != &::google::protobuf::internal::kEmptyString) {
        file_type_->clear();
      }
    }
    status_result_ = 1;
    if (has_virus_name()) {
      if (virus_name_ != &::google::protobuf::internal::kEmptyString) {
        virus_name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_binary()) {
      if (binary_ != &::google::protobuf::internal::kEmptyString) {
        binary_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InfectedFileInfoRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_machine_name;
        break;
      }

      // optional bytes machine_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_machine_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_machine_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ip;
        break;
      }

      // optional bytes ip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_encode_sig_type;
        break;
      }

      // optional .scan_threat.InfectedFileInfoRequest.EncodeType encode_sig_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encode_sig_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::scan_threat::InfectedFileInfoRequest_EncodeType_IsValid(value)) {
            set_encode_sig_type(static_cast< ::scan_threat::InfectedFileInfoRequest_EncodeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_file_name;
        break;
      }

      // optional bytes file_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_file_type;
        break;
      }

      // optional bytes file_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_file_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_status_result;
        break;
      }

      // optional .scan_threat.InfectedFileInfoRequest.StatusResult status_result = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::scan_threat::InfectedFileInfoRequest_StatusResult_IsValid(value)) {
            set_status_result(static_cast< ::scan_threat::InfectedFileInfoRequest_StatusResult >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_virus_name;
        break;
      }

      // optional bytes virus_name = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_virus_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_virus_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_binary;
        break;
      }

      // optional bytes binary = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_binary:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_binary()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InfectedFileInfoRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->uuid(), output);
  }

  // optional bytes machine_name = 2;
  if (has_machine_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->machine_name(), output);
  }

  // optional bytes ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->ip(), output);
  }

  // optional .scan_threat.InfectedFileInfoRequest.EncodeType encode_sig_type = 4;
  if (has_encode_sig_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->encode_sig_type(), output);
  }

  // optional bytes file_name = 5;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->file_name(), output);
  }

  // optional bytes file_type = 6;
  if (has_file_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->file_type(), output);
  }

  // optional .scan_threat.InfectedFileInfoRequest.StatusResult status_result = 7;
  if (has_status_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->status_result(), output);
  }

  // optional bytes virus_name = 8;
  if (has_virus_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->virus_name(), output);
  }

  // optional bytes binary = 9;
  if (has_binary()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->binary(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InfectedFileInfoRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes uuid = 1;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->uuid(), target);
  }

  // optional bytes machine_name = 2;
  if (has_machine_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->machine_name(), target);
  }

  // optional bytes ip = 3;
  if (has_ip()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->ip(), target);
  }

  // optional .scan_threat.InfectedFileInfoRequest.EncodeType encode_sig_type = 4;
  if (has_encode_sig_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->encode_sig_type(), target);
  }

  // optional bytes file_name = 5;
  if (has_file_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->file_name(), target);
  }

  // optional bytes file_type = 6;
  if (has_file_type()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->file_type(), target);
  }

  // optional .scan_threat.InfectedFileInfoRequest.StatusResult status_result = 7;
  if (has_status_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->status_result(), target);
  }

  // optional bytes virus_name = 8;
  if (has_virus_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->virus_name(), target);
  }

  // optional bytes binary = 9;
  if (has_binary()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        9, this->binary(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InfectedFileInfoRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // optional bytes machine_name = 2;
    if (has_machine_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->machine_name());
    }

    // optional bytes ip = 3;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ip());
    }

    // optional .scan_threat.InfectedFileInfoRequest.EncodeType encode_sig_type = 4;
    if (has_encode_sig_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->encode_sig_type());
    }

    // optional bytes file_name = 5;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->file_name());
    }

    // optional bytes file_type = 6;
    if (has_file_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->file_type());
    }

    // optional .scan_threat.InfectedFileInfoRequest.StatusResult status_result = 7;
    if (has_status_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status_result());
    }

    // optional bytes virus_name = 8;
    if (has_virus_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->virus_name());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes binary = 9;
    if (has_binary()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->binary());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InfectedFileInfoRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InfectedFileInfoRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InfectedFileInfoRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InfectedFileInfoRequest::MergeFrom(const InfectedFileInfoRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_machine_name()) {
      set_machine_name(from.machine_name());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_encode_sig_type()) {
      set_encode_sig_type(from.encode_sig_type());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_type()) {
      set_file_type(from.file_type());
    }
    if (from.has_status_result()) {
      set_status_result(from.status_result());
    }
    if (from.has_virus_name()) {
      set_virus_name(from.virus_name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_binary()) {
      set_binary(from.binary());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InfectedFileInfoRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InfectedFileInfoRequest::CopyFrom(const InfectedFileInfoRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfectedFileInfoRequest::IsInitialized() const {

  return true;
}

void InfectedFileInfoRequest::Swap(InfectedFileInfoRequest* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(machine_name_, other->machine_name_);
    std::swap(ip_, other->ip_);
    std::swap(encode_sig_type_, other->encode_sig_type_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_type_, other->file_type_);
    std::swap(status_result_, other->status_result_);
    std::swap(virus_name_, other->virus_name_);
    std::swap(binary_, other->binary_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InfectedFileInfoRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InfectedFileInfoRequest_descriptor_;
  metadata.reflection = InfectedFileInfoRequest_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* InfectedFileInfoResponse_EncodeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoResponse_EncodeType_descriptor_;
}
bool InfectedFileInfoResponse_EncodeType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfoResponse_EncodeType InfectedFileInfoResponse::MD5;
const InfectedFileInfoResponse_EncodeType InfectedFileInfoResponse::MD5_HEADER;
const InfectedFileInfoResponse_EncodeType InfectedFileInfoResponse::MD5_BODY;
const InfectedFileInfoResponse_EncodeType InfectedFileInfoResponse::SHA_1;
const InfectedFileInfoResponse_EncodeType InfectedFileInfoResponse::SHA_256;
const InfectedFileInfoResponse_EncodeType InfectedFileInfoResponse::SSDEEP;
const InfectedFileInfoResponse_EncodeType InfectedFileInfoResponse::EncodeType_MIN;
const InfectedFileInfoResponse_EncodeType InfectedFileInfoResponse::EncodeType_MAX;
const int InfectedFileInfoResponse::EncodeType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* InfectedFileInfoResponse_FileType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoResponse_FileType_descriptor_;
}
bool InfectedFileInfoResponse_FileType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfoResponse_FileType InfectedFileInfoResponse::PE;
const InfectedFileInfoResponse_FileType InfectedFileInfoResponse::ELF;
const InfectedFileInfoResponse_FileType InfectedFileInfoResponse::PROCESS;
const InfectedFileInfoResponse_FileType InfectedFileInfoResponse::FileType_MIN;
const InfectedFileInfoResponse_FileType InfectedFileInfoResponse::FileType_MAX;
const int InfectedFileInfoResponse::FileType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* InfectedFileInfoResponse_StatusResult_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoResponse_StatusResult_descriptor_;
}
bool InfectedFileInfoResponse_StatusResult_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InfectedFileInfoResponse_StatusResult InfectedFileInfoResponse::POSITIVE;
const InfectedFileInfoResponse_StatusResult InfectedFileInfoResponse::NEGATIVE;
const InfectedFileInfoResponse_StatusResult InfectedFileInfoResponse::StatusResult_MIN;
const InfectedFileInfoResponse_StatusResult InfectedFileInfoResponse::StatusResult_MAX;
const int InfectedFileInfoResponse::StatusResult_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int InfectedFileInfoResponse::kUuidFieldNumber;
const int InfectedFileInfoResponse::kMachineNameFieldNumber;
const int InfectedFileInfoResponse::kIpFieldNumber;
const int InfectedFileInfoResponse::kEncodeSigTypeFieldNumber;
const int InfectedFileInfoResponse::kFileNameFieldNumber;
const int InfectedFileInfoResponse::kFileTypeFieldNumber;
const int InfectedFileInfoResponse::kStatusResultFieldNumber;
const int InfectedFileInfoResponse::kVirusNameFieldNumber;
const int InfectedFileInfoResponse::kBinaryFieldNumber;
#endif  // !_MSC_VER

InfectedFileInfoResponse::InfectedFileInfoResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InfectedFileInfoResponse::InitAsDefaultInstance() {
}

InfectedFileInfoResponse::InfectedFileInfoResponse(const InfectedFileInfoResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InfectedFileInfoResponse::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encode_sig_type_ = 1;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_result_ = 1;
  virus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  binary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InfectedFileInfoResponse::~InfectedFileInfoResponse() {
  SharedDtor();
}

void InfectedFileInfoResponse::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_name_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_type_ != &::google::protobuf::internal::kEmptyString) {
    delete file_type_;
  }
  if (virus_name_ != &::google::protobuf::internal::kEmptyString) {
    delete virus_name_;
  }
  if (binary_ != &::google::protobuf::internal::kEmptyString) {
    delete binary_;
  }
  if (this != default_instance_) {
  }
}

void InfectedFileInfoResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InfectedFileInfoResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoResponse_descriptor_;
}

const InfectedFileInfoResponse& InfectedFileInfoResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_message_5ftracethreat_2eproto();
  return *default_instance_;
}

InfectedFileInfoResponse* InfectedFileInfoResponse::default_instance_ = NULL;

InfectedFileInfoResponse* InfectedFileInfoResponse::New() const {
  return new InfectedFileInfoResponse;
}

void InfectedFileInfoResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    if (has_machine_name()) {
      if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
        machine_name_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    encode_sig_type_ = 1;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    if (has_file_type()) {
      if (file_type_ != &::google::protobuf::internal::kEmptyString) {
        file_type_->clear();
      }
    }
    status_result_ = 1;
    if (has_virus_name()) {
      if (virus_name_ != &::google::protobuf::internal::kEmptyString) {
        virus_name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_binary()) {
      if (binary_ != &::google::protobuf::internal::kEmptyString) {
        binary_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InfectedFileInfoResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_machine_name;
        break;
      }

      // optional bytes machine_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_machine_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_machine_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ip;
        break;
      }

      // optional bytes ip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_encode_sig_type;
        break;
      }

      // optional .scan_threat.InfectedFileInfoResponse.EncodeType encode_sig_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encode_sig_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::scan_threat::InfectedFileInfoResponse_EncodeType_IsValid(value)) {
            set_encode_sig_type(static_cast< ::scan_threat::InfectedFileInfoResponse_EncodeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_file_name;
        break;
      }

      // optional bytes file_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_file_type;
        break;
      }

      // optional bytes file_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_file_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_status_result;
        break;
      }

      // optional .scan_threat.InfectedFileInfoResponse.StatusResult status_result = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::scan_threat::InfectedFileInfoResponse_StatusResult_IsValid(value)) {
            set_status_result(static_cast< ::scan_threat::InfectedFileInfoResponse_StatusResult >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_virus_name;
        break;
      }

      // optional bytes virus_name = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_virus_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_virus_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_binary;
        break;
      }

      // optional bytes binary = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_binary:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_binary()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InfectedFileInfoResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->uuid(), output);
  }

  // optional bytes machine_name = 2;
  if (has_machine_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->machine_name(), output);
  }

  // optional bytes ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->ip(), output);
  }

  // optional .scan_threat.InfectedFileInfoResponse.EncodeType encode_sig_type = 4;
  if (has_encode_sig_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->encode_sig_type(), output);
  }

  // optional bytes file_name = 5;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->file_name(), output);
  }

  // optional bytes file_type = 6;
  if (has_file_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->file_type(), output);
  }

  // optional .scan_threat.InfectedFileInfoResponse.StatusResult status_result = 7;
  if (has_status_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->status_result(), output);
  }

  // optional bytes virus_name = 8;
  if (has_virus_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->virus_name(), output);
  }

  // optional bytes binary = 9;
  if (has_binary()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->binary(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InfectedFileInfoResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes uuid = 1;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->uuid(), target);
  }

  // optional bytes machine_name = 2;
  if (has_machine_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->machine_name(), target);
  }

  // optional bytes ip = 3;
  if (has_ip()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->ip(), target);
  }

  // optional .scan_threat.InfectedFileInfoResponse.EncodeType encode_sig_type = 4;
  if (has_encode_sig_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->encode_sig_type(), target);
  }

  // optional bytes file_name = 5;
  if (has_file_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->file_name(), target);
  }

  // optional bytes file_type = 6;
  if (has_file_type()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->file_type(), target);
  }

  // optional .scan_threat.InfectedFileInfoResponse.StatusResult status_result = 7;
  if (has_status_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->status_result(), target);
  }

  // optional bytes virus_name = 8;
  if (has_virus_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->virus_name(), target);
  }

  // optional bytes binary = 9;
  if (has_binary()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        9, this->binary(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InfectedFileInfoResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // optional bytes machine_name = 2;
    if (has_machine_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->machine_name());
    }

    // optional bytes ip = 3;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ip());
    }

    // optional .scan_threat.InfectedFileInfoResponse.EncodeType encode_sig_type = 4;
    if (has_encode_sig_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->encode_sig_type());
    }

    // optional bytes file_name = 5;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->file_name());
    }

    // optional bytes file_type = 6;
    if (has_file_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->file_type());
    }

    // optional .scan_threat.InfectedFileInfoResponse.StatusResult status_result = 7;
    if (has_status_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status_result());
    }

    // optional bytes virus_name = 8;
    if (has_virus_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->virus_name());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes binary = 9;
    if (has_binary()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->binary());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InfectedFileInfoResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InfectedFileInfoResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InfectedFileInfoResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InfectedFileInfoResponse::MergeFrom(const InfectedFileInfoResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_machine_name()) {
      set_machine_name(from.machine_name());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_encode_sig_type()) {
      set_encode_sig_type(from.encode_sig_type());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_type()) {
      set_file_type(from.file_type());
    }
    if (from.has_status_result()) {
      set_status_result(from.status_result());
    }
    if (from.has_virus_name()) {
      set_virus_name(from.virus_name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_binary()) {
      set_binary(from.binary());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InfectedFileInfoResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InfectedFileInfoResponse::CopyFrom(const InfectedFileInfoResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfectedFileInfoResponse::IsInitialized() const {

  return true;
}

void InfectedFileInfoResponse::Swap(InfectedFileInfoResponse* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(machine_name_, other->machine_name_);
    std::swap(ip_, other->ip_);
    std::swap(encode_sig_type_, other->encode_sig_type_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_type_, other->file_type_);
    std::swap(status_result_, other->status_result_);
    std::swap(virus_name_, other->virus_name_);
    std::swap(binary_, other->binary_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InfectedFileInfoResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InfectedFileInfoResponse_descriptor_;
  metadata.reflection = InfectedFileInfoResponse_reflection_;
  return metadata;
}


// ===================================================================

InfectedFileInfoService::~InfectedFileInfoService() {}

const ::google::protobuf::ServiceDescriptor* InfectedFileInfoService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* InfectedFileInfoService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return InfectedFileInfoService_descriptor_;
}

void InfectedFileInfoService::InfectedFileInfo(::google::protobuf::RpcController* controller,
                         const ::scan_threat::InfectedFileInfoRequest*,
                         ::scan_threat::InfectedFileInfoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method InfectedFileInfo() not implemented.");
  done->Run();
}

void InfectedFileInfoService::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), InfectedFileInfoService_descriptor_);
  switch(method->index()) {
    case 0:
      InfectedFileInfo(controller,
             ::google::protobuf::down_cast<const ::scan_threat::InfectedFileInfoRequest*>(request),
             ::google::protobuf::down_cast< ::scan_threat::InfectedFileInfoResponse*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& InfectedFileInfoService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::scan_threat::InfectedFileInfoRequest::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& InfectedFileInfoService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::scan_threat::InfectedFileInfoResponse::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

InfectedFileInfoService_Stub::InfectedFileInfoService_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
InfectedFileInfoService_Stub::InfectedFileInfoService_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
InfectedFileInfoService_Stub::~InfectedFileInfoService_Stub() {
  if (owns_channel_) delete channel_;
}

void InfectedFileInfoService_Stub::InfectedFileInfo(::google::protobuf::RpcController* controller,
                              const ::scan_threat::InfectedFileInfoRequest* request,
                              ::scan_threat::InfectedFileInfoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace scan_threat

// @@protoc_insertion_point(global_scope)
